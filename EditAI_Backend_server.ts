import express, { Express, Request, Response } from 'express';\nimport cors from 'cors';\nimport dotenv from 'dotenv';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcrypt';\nimport { Pool } from 'pg';\nimport OpenAI from 'openai';\nimport Stripe from 'stripe';\n\ndotenv.config();\n\nconst app: Express = express();\nconst port = process.env.PORT || 5000;\n\n// Middleware\napp.use(cors());\napp.use(express.json());\n\n// Database\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\n// OpenAI\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\n// Stripe\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', {\n  apiVersion: '2023-10-16',\n});\n\n// Types\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n  subscription_tier: 'free' | 'pro' | 'team';\n}\n\ninterface EditPlan {\n  plan_id: string;\n  title: string;\n  scenes: Scene[];\n  captions: Caption[];\n  animations: Animation[];\n  transitions: Transition[];\n}\n\ninterface Scene {\n  id: string;\n  start_time: string;\n  end_time: string;\n  action: 'KEEP' | 'CUT' | 'TRIM' | 'SLOW' | 'SPEED';\n  reason?: string;\n}\n\ninterface Caption {\n  id: string;\n  time: string;\n  text: string;\n  style: string;\n  duration: string;\n}\n\ninterface Animation {\n  id: string;\n  type: string;\n  duration: string;\n  timing: string;\n  properties?: Record<string, any>;\n}\n\ninterface Transition {\n  id: string;\n  type: string;\n  duration: string;\n}\n\n// Middleware: Auth\nconst authMiddleware = (req: any, res: Response, next: any) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token' });\n\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret');\n    req.user = decoded;\n    next();\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n};\n\n// Routes: Auth\napp.post('/api/auth/register', async (req: Request, res: Response) => {\n  try {\n    const { email, password, name } = req.body;\n\n    // Check if user exists\n    const existing = await pool.query('SELECT * FROM users WHERE email = $1', [email]);\n    if (existing.rows.length > 0) {\n      return res.status(400).json({ error: 'User already exists' });\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    // Create user\n    const result = await pool.query(\n      'INSERT INTO users (email, password_hash, name, subscription_tier) VALUES ($1, $2, $3, $4) RETURNING id, email, name, subscription_tier',\n      [email, hashedPassword, name, 'free']\n    );\n\n    const user = result.rows[0];\n    const token = jwt.sign(\n      { id: user.id, email: user.email },\n      process.env.JWT_SECRET || 'secret',\n      { expiresIn: '30d' }\n    );\n\n    res.json({ user, token });\n  } catch (err) {\n    console.error(err);\n    res.status(500).json({ error: 'Registration failed' });\n  }\n});\n\napp.post('/api/auth/login', async (req: Request, res: Response) => {\n  try {\n    const { email, password } = req.body;\n\n    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);\n    if (result.rows.length === 0) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n\n    const user = result.rows[0];\n    const passwordMatch = await bcrypt.compare(password, user.password_hash);\n    if (!passwordMatch) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n\n    const token = jwt.sign(\n      { id: user.id, email: user.email },\n      process.env.JWT_SECRET || 'secret',\n      { expiresIn: '30d' }\n    );\n\n    res.json({\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        subscription_tier: user.subscription_tier,\n      },\n      token,\n    });\n  } catch (err) {\n    res.status(500).json({ error: 'Login failed' });\n  }\n});\n\napp.get('/api/auth/me', authMiddleware, async (req: any, res: Response) => {\n  try {\n    const result = await pool.query('SELECT id, email, name, subscription_tier FROM users WHERE id = $1', [\n      req.user.id,\n    ]);\n    res.json(result.rows[0]);\n  } catch (err) {\n    res.status(500).json({ error: 'Failed to fetch user' });\n  }\n});\n\n// Routes: Edit Plans\napp.post('/api/plans/generate', authMiddleware, async (req: any, res: Response) => {\n  try {\n    const { command, video_title } = req.body;\n    const userId = req.user.id;\n\n    // Check usage limit\n    const user = await pool.query('SELECT subscription_tier FROM users WHERE id = $1', [userId]);\n    if (user.rows[0].subscription_tier === 'free') {\n      const thisMonth = await pool.query(\n        'SELECT COUNT(*) FROM edit_plans WHERE user_id = $1 AND EXTRACT(MONTH FROM created_at) = EXTRACT(MONTH FROM NOW())',\n        [userId]\n      );\n      if (parseInt(thisMonth.rows[0].count) >= 5) {\n        return res.status(403).json({ error: 'Free tier limit reached' });\n      }\n    }\n\n    // Generate edit plan with AI\n    const systemPrompt = `You are a creative director for social media video editing.\nConvert user commands into structured edit plans.\nONLY use predefined assets.\nOutput ONLY valid JSON.`;\n\n    const response = await openai.chat.completions.create({\n      model: 'gpt-4',\n      messages: [\n        {\n          role: 'system',\n          content: systemPrompt,\n        },\n        {\n          role: 'user',\n          content: `Command: \"${command}\"`,\n        },\n      ],\n      temperature: 0.7,\n      max_tokens: 2000,\n    });\n\n    const content = response.choices[0].message.content;\n    const editPlan = JSON.parse(content || '{}');\n\n    // Save to database\n    const result = await pool.query(\n      'INSERT INTO edit_plans (user_id, title, video_title, command, plan_json, status) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *',\n      [userId, editPlan.title || 'Untitled', video_title, command, JSON.stringify(editPlan), 'completed']\n    );\n\n    res.json(result.rows[0]);\n  } catch (err) {\n    console.error(err);\n    res.status(500).json({ error: 'Failed to generate plan' });\n  }\n});\n\napp.get('/api/plans', authMiddleware, async (req: any, res: Response) => {\n  try {\n    const result = await pool.query(\n      'SELECT id, title, video_title, status, created_at FROM edit_plans WHERE user_id = $1 ORDER BY created_at DESC',\n      [req.user.id]\n    );\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).json({ error: 'Failed to fetch plans' });\n  }\n});\n\napp.get('/api/plans/:id', authMiddleware, async (req: any, res: Response) => {\n  try {\n    const result = await pool.query(\n      'SELECT * FROM edit_plans WHERE id = $1 AND user_id = $2',\n      [req.params.id, req.user.id]\n    );\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Plan not found' });\n    }\n    res.json(result.rows[0]);\n  } catch (err) {\n    res.status(500).json({ error: 'Failed to fetch plan' });\n  }\n});\n\napp.delete('/api/plans/:id', authMiddleware, async (req: any, res: Response) => {\n  try {\n    const result = await pool.query(\n      'DELETE FROM edit_plans WHERE id = $1 AND user_id = $2 RETURNING id',\n      [req.params.id, req.user.id]\n    );\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Plan not found' });\n    }\n    res.json({ success: true });\n  } catch (err) {\n    res.status(500).json({ error: 'Failed to delete plan' });\n  }\n});\n\n// Routes: Subscription\napp.post('/api/subscription/checkout', authMiddleware, async (req: any, res: Response) => {\n  try {\n    const { tier } = req.body;\n    const userId = req.user.id;\n\n    const prices: Record<string, string> = {\n      pro: process.env.STRIPE_PRICE_PRO || 'price_1234567890',\n      team: process.env.STRIPE_PRICE_TEAM || 'price_0987654321',\n    };\n\n    const session = await stripe.checkout.sessions.create({\n      payment_method_types: ['card'],\n      line_items: [\n        {\n          price: prices[tier],\n          quantity: 1,\n        },\n      ],\n      mode: 'subscription',\n      success_url: `${process.env.FRONTEND_URL}/success?session_id={CHECKOUT_SESSION_ID}`,\n      cancel_url: `${process.env.FRONTEND_URL}/pricing`,\n      metadata: {\n        userId,\n        tier,\n      },\n    });\n\n    res.json({ url: session.url });\n  } catch (err) {\n    res.status(500).json({ error: 'Failed to create checkout session' });\n  }\n});\n\napp.post('/api/webhook/stripe', express.raw({ type: 'application/json' }), async (req: Request, res: Response) => {\n  const sig = req.headers['stripe-signature'] as string;\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET || '';\n\n  try {\n    const event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n\n    if (event.type === 'customer.subscription.updated') {\n      const subscription = event.data.object as any;\n      const userId = subscription.metadata.userId;\n      const tier = subscription.metadata.tier;\n\n      await pool.query(\n        'UPDATE users SET subscription_tier = $1 WHERE id = $2',\n        [tier, userId]\n      );\n    }\n\n    if (event.type === 'customer.subscription.deleted') {\n      const subscription = event.data.object as any;\n      const userId = subscription.metadata.userId;\n\n      await pool.query(\n        'UPDATE users SET subscription_tier = $1 WHERE id = $2',\n        ['free', userId]\n      );\n    }\n\n    res.json({ received: true });\n  } catch (err) {\n    console.error(err);\n    res.status(400).json({ error: 'Webhook error' });\n  }\n});\n\n// Health check\napp.get('/health', (req: Request, res: Response) => {\n  res.json({ status: 'ok' });\n});\n\n// Start server\napp.listen(port, () => {\n  console.log(`EditAI server running on port ${port}`);\n});\n\nexport default app;\n
